<html>
<head>
  <title>CTFshow Misc 15（57-60）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602628 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3084"/>
<h1>CTFshow Misc 15（57-60）</h1>

<div>
<span><div><span style="font-weight: bold;">57 知否</span></div><div><br/></div><div>下载得到png格式图片。Stegsolve查看，在Red/Green plane 0处发现线索：</div><div><img src="CTFshow Misc 15（57-60）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><img src="CTFshow Misc 15（57-60）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>另一方面，注意到Red/Green Plane 0的右半部分和Blue Plane 0都是全黑的，这显然是经过处理的痕迹。换言之，隐写信息很可能就在R/G通道的最低位处。更确切地说，是在最左边80列像素的R/G通道最低位处，且读取时像素顺序可能为列优先。</div><div><br/></div><div>信息的隐藏方式有多种可能，分别用脚本输出开头部分：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>img = Image.open('C:/Users/Administrator/Desktop/flag_out.png')</div><div><br/></div><div># 先读全部像素R通道最低位，再读G通道最低位</div><div>res = ''</div><div>for i in range(200):</div><div>    p = img.getpixel((0, i))</div><div>    res += str(p[0] % 2)</div><div>    if len(res) == 8:</div><div>        print(str(hex(int(res, 2)))[2:].zfill(2), end = ' ')</div><div>        res = ''</div><div># 76 2d 21 b8 f2 f1 60 d0 7e 12 93 12 b2 33 bb 09 e0 43 9e 89 17 91 e9 eb 72</div><div><br/></div><div># 先读某个像素R通道最低位，再读G通道最低位，再读下个像素</div><div>res = ''</div><div>for i in range(100):</div><div>    p = img.getpixel((0, i))</div><div>    res += str(p[0] % 2)</div><div>    res += str(p[1] % 2)</div><div>    if len(res) == 8:</div><div>        print(str(hex(int(res, 2)))[2:].zfill(2), end = ' ')</div><div>        res = ''</div><div># 6e 79 19 b3 1c 56 9b d5 be 59 ee 47 3d 44 a2 44 2e ac 03 0c 82 0a 03 5d 9f</div><div><br/></div><div># 读取某个像素R通道最低位和G通道最低位的异或结果</div><div>res = ''</div><div>for i in range(200):</div><div>    p = img.getpixel((0, i))</div><div>    res += str((p[0] % 2) ^ (p[1] % 2))</div><div>    if len(res) == 8:</div><div>        print(str(hex(int(res, 2)))[2:].zfill(2), end = ' ')</div><div>        res = ''</div><div># db 78 4f e7 9f 5a 1a da 5c 00 93 0d c9 5b 67 53 40 42 19 56 12 10 88 7f 1a</div><div><br/></div><div># 对每个像素判断R通道最低位是否小于G通道最低位（绿肥红瘦）</div><div>res = ''</div><div>for i in range(200):</div><div>    p = img.getpixel((0, i))</div><div>    if p[0] % 2 &lt; p[1] % 2:</div><div>        res += '1'</div><div>    else:</div><div>        res += '0'</div><div>    if len(res) == 8:</div><div>        print(str(hex(int(res, 2)))[2:].zfill(2), end = ' ')</div><div>        res = ''</div><div># 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 00 00 01 56 00 00 00 14 08</div></div><div>最后一种方式输出了明显的PNG格式图片文件头，按这种方式读取全部80列像素并保存为PNG格式图片：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/flag_out.png')</div><div>png = open('C:/Users/Administrator/Desktop/flag.png', 'ab')</div><div>tmp = ''</div><div><br/></div><div>for i in range(80):</div><div>    for j in range(img.size[1]):</div><div>        p = img.getpixel((i, j))</div><div>        if p[0] % 2 &lt; p[1] % 2:</div><div>            tmp += '1'</div><div>        else:</div><div>            tmp += '0'</div><div>        if len(tmp) == 8:</div><div>            png.write(int(tmp, 2).to_bytes(1, 'big'))</div><div>            tmp = ''</div></div><div>运行得到图片：</div><div><img src="CTFshow Misc 15（57-60）_files/flag.png" type="image/png" data-filename="flag.png"/></div><div><br/></div><div>flag：flag{aff3a6fb7c7f6c6ae306e8ebde002ffc}</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">58 小球</span></div><div><br/></div><div>下载得到gif格式文件。查看图像信息，共有305帧，每帧的背景图都一致，除第0帧外，第1-304帧都是背景图上覆盖了一个大小、位置随机的圆，颜色有绿色和蓝色两种。第0帧：</div><div><img src="CTFshow Misc 15（57-60）_files/0.png" type="image/png" data-filename="0.png"/></div><div>第7帧：</div><div><img src="CTFshow Misc 15（57-60）_files/7.png" type="image/png" data-filename="7.png"/></div><div>第22帧：</div><div><span style="font-weight: bold;"><img src="CTFshow Misc 15（57-60）_files/22.png" type="image/png" data-filename="22.png"/></span></div><div><br/></div><div>显然这个圆就是携带信息的载体，其圆心坐标、半径和颜色都有可能携带了信息。但考虑到在像素图中半径是离散的整数值且取值范围不大，圆心坐标计算方式比较复杂，先从比较容易获取的颜色入手。记录除第1-16帧的小圆颜色：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>蓝绿绿蓝蓝绿绿蓝蓝绿绿蓝绿绿蓝蓝</div></div><div>容易联想到 fl 的二进制ASCII码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01100110 01101100</div></div><div>显然蓝色对应0，绿色对应1，除第0帧外的304帧正好对应38个字符。</div><div><br/></div><div>现在需要提取每一帧中小圆的颜色。容易想到的一种方法是循环读取每一帧的每个像素，一旦有像素的RGB值为纯蓝或纯绿就跳出循环，并记录该帧对应的颜色值。但这种方法在背景图中也包含纯蓝或纯绿像素时就会失效，因此尝试采用另一种更有通用性的方式，将每一帧与第0帧进行比较。如果某一帧的像素整体上“更蓝”，就可以判定该帧的小圆是蓝色。预先将每一帧导出为PNG格式图片后运行以下Python脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>def sum_B(img):</div><div>    B = 0</div><div>    for i in range(img.size[0]):</div><div>        for j in range(img.size[1]):</div><div>            B += img.getpixel((i, j))[2]</div><div>    return(B)</div><div><br/></div><div>img0 = Image.open('C:/Users/Administrator/Desktop/qiu/0.png')</div><div>B0 = sum_B(img0)</div><div><br/></div><div>res = ''</div><div>for i in range(1, 305):</div><div>    path = 'C:/Users/Administrator/Desktop/qiu/' + str(i) + '.png'</div><div>    B = sum_B(Image.open(path))</div><div>    if B &gt; B0:</div><div>        res += '0'</div><div>    else:</div><div>        res += '1'</div><div>    if len(res) == 8:</div><div>        print(chr(int(res, 2)), end = '')</div><div>        res = ''</div></div><div>该方法笨重、缓慢但是有效，而且flag一个字符一个字符蹦出来很有盲注的感觉。输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{82f6d14327ad10e0f9105b409122d5e1}</div></div><div><br/></div><div>flag：flag{82f6d14327ad10e0f9105b409122d5e1}</div><div><br/></div><div><span style="font-weight: bold;">59 LSB</span></div><div><br/></div><div><span style="font-size: unset;">做不来，告辞！</span></div><div>以下是参考出题人解答的解题脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import wave</div><div>import numpy as np</div><div><br/></div><div>f = wave.open('C:/Users/Administrator/Desktop/example.wav', 'rb')</div><div>params = f.getparams()</div><div>nchaanels, sampwith, frameate, nframes = params[:4]</div><div>strData = f.readframes(nframes)</div><div>data = np.frombuffer(strData, dtype = np.int16).tolist()</div><div><br/></div><div>data = data[::-1]</div><div>tmp = ''</div><div>res = []</div><div>for i in data:</div><div>    if i % 2 == 1:</div><div>        tmp += '1'</div><div>    else:</div><div>        tmp += '0'</div><div>    if len(tmp) == 8:</div><div>        res += [int(tmp, 2)]</div><div>        tmp = ''</div><div><br/></div><div>png = open('C:/Users/Administrator/Desktop/1.png', 'wb')</div><div>png.write(bytes(res[::-1]))</div></div><div><br/></div><div>flag：flag{0eaf0a5e30b495f5490ec8baad0e9a53}</div><div><br/></div><div><span style="font-weight: bold;">60 Hi_433MHz</span></div><div><br/></div><div>下载得到rf.s8文件，没见过的扩展名，file命令看一下文件类型：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# file rf.s8</div><div>rf.s8: data</div></div><div>嗯……所以是某种数据的文件，从文件名里的MHz这个单位来看可能是与声音相关的数据，尝试拖进audacity：</div><div><img src="CTFshow Misc 15（57-60）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>按说明导入数据，选项看不懂，暂时保持默认：</div><div><img src="CTFshow Misc 15（57-60）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>拉伸一下横坐标轴，可以看到长音和短音组成的多组声音信号：</div><div><img src="CTFshow Misc 15（57-60）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>观察一下规律：</div><div>1、每组有9个声音信号；</div><div>2、每组的开头和结尾必然是短音。</div><div>尝试将长音和短音分别替换成1和0，记录开头四组：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>011001100 011011000 011000010 011001110</div></div><div>联想到 flag 的二进制ASCII码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01100110 01101100 01100001 01100111</div></div><div>显然每组声音信号去掉末尾的0就是对应字符的二进制ASCII码。</div><div><br/></div><div>记录全部声音信号：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>011001100 011011000 011000010 011001110 011110110 001100100 001101010 011000110 001100100 001100010 011000100 001100000 011001000 001011010 001101100 011000010 001100010 001100010 001011010 001101000 001100110 001100010 001100100 001011010 001110010 001101110 001100010 011000100 001011010 001101000 001100100 001110000 011001000 001100000 001100010 011000110 011001000 011000110 001101010 001100110 001101000 011111010</div></div><div>去掉每组末尾的0：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01100110 01101100 01100001 01100111 01111011 00110010 00110101 01100011 00110010 00110001 01100010 00110000 01100100 00101101 00110110 01100001 00110001 00110001 00101101 00110100 00110011 00110001 00110010 00101101 00111001 00110111 00110001 01100010 00101101 00110100 00110010 00111000 01100100 00110000 00110001 01100011 01100100 01100011 00110101 00110011 00110100 01111101</div></div><div>二进制ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{25c21b0d-6a11-4312-971b-428d01cdc534}</div></div><div><br/></div><div>flag：flag{25c21b0d-6a11-4312-971b-428d01cdc534}</div></span>
</div></body></html> 